---
name: CI

on:
  pull_request:
  push:
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm test -- --coverage --coverageReporters=json-summary --coverageReporters=text

      - name: Upload PR coverage artifact
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-pr-${{ github.sha }}
          path: coverage/coverage-summary.json
          retention-days: 5

      - name: Cache main branch coverage
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/cache/save@v4
        with:
          path: coverage/coverage-summary.json
          key: coverage-main-${{ github.sha }}

      - name: Update latest main coverage cache
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/cache/save@v4
        with:
          path: coverage/coverage-summary.json
          key: coverage-main-latest

  coverage-report:
    name: Heimdallr Coverage Report
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request'

    steps:
      - name: Download PR coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-pr-${{ github.sha }}
          path: pr-coverage

      - name: Get PR coverage values
        id: pr-coverage
        run: |
          STATEMENTS=$(jq '.total.statements.pct' pr-coverage/coverage-summary.json)
          BRANCHES=$(jq '.total.branches.pct' pr-coverage/coverage-summary.json)
          FUNCTIONS=$(jq '.total.functions.pct' pr-coverage/coverage-summary.json)
          LINES=$(jq '.total.lines.pct' pr-coverage/coverage-summary.json)
          {
            echo "statements=$STATEMENTS"
            echo "branches=$BRANCHES"
            echo "functions=$FUNCTIONS"
            echo "lines=$LINES"
          } >> "$GITHUB_OUTPUT"

      - name: Restore main branch coverage from cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: base-coverage/coverage-summary.json
          key: coverage-main-latest

      - name: Get base coverage values
        id: base-coverage
        run: |
          if [ -f base-coverage/coverage-summary.json ]; then
            STATEMENTS=$(jq '.total.statements.pct' base-coverage/coverage-summary.json)
            BRANCHES=$(jq '.total.branches.pct' base-coverage/coverage-summary.json)
            FUNCTIONS=$(jq '.total.functions.pct' base-coverage/coverage-summary.json)
            LINES=$(jq '.total.lines.pct' base-coverage/coverage-summary.json)
          else
            echo "No cached coverage found for main branch, using 0"
            STATEMENTS=0
            BRANCHES=0
            FUNCTIONS=0
            LINES=0
          fi
          {
            echo "statements=$STATEMENTS"
            echo "branches=$BRANCHES"
            echo "functions=$FUNCTIONS"
            echo "lines=$LINES"
          } >> "$GITHUB_OUTPUT"

      - name: Calculate coverage diff and check thresholds
        id: diff
        run: |
          PR_STMT="${{ steps.pr-coverage.outputs.statements }}"
          BASE_STMT="${{ steps.base-coverage.outputs.statements }}"

          STMT_DIFF=$(echo "$PR_STMT - $BASE_STMT" | bc)
          echo "stmt_diff=$STMT_DIFF" >> "$GITHUB_OUTPUT"

          # Check if coverage decreased (using bc for float comparison)
          DECREASED=$(echo "$STMT_DIFF < 0" | bc -l)
          if [ "$DECREASED" = "1" ]; then
            echo "coverage_decreased=true" >> "$GITHUB_OUTPUT"
          else
            echo "coverage_decreased=false" >> "$GITHUB_OUTPUT"
          fi

          # Check if below minimum threshold (25%)
          BELOW_MIN=$(echo "$PR_STMT < 25" | bc -l)
          if [ "$BELOW_MIN" = "1" ]; then
            echo "below_minimum=true" >> "$GITHUB_OUTPUT"
          else
            echo "below_minimum=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.HEIMDALLR_TOKEN }}
          script: |
            const prStmt = ${{ steps.pr-coverage.outputs.statements }};
            const prBranch = ${{ steps.pr-coverage.outputs.branches }};
            const prFunc = ${{ steps.pr-coverage.outputs.functions }};
            const prLines = ${{ steps.pr-coverage.outputs.lines }};

            const baseStmt = ${{ steps.base-coverage.outputs.statements }};
            const baseBranch = ${{ steps.base-coverage.outputs.branches }};
            const baseFunc = ${{ steps.base-coverage.outputs.functions }};
            const baseLines = ${{ steps.base-coverage.outputs.lines }};

            const stmtDiff = (prStmt - baseStmt).toFixed(2);
            const branchDiff = (prBranch - baseBranch).toFixed(2);
            const funcDiff = (prFunc - baseFunc).toFixed(2);
            const linesDiff = (prLines - baseLines).toFixed(2);

            const belowMinimum = '${{ steps.diff.outputs.below_minimum }}' === 'true';
            const coverageDecreased = '${{ steps.diff.outputs.coverage_decreased }}' === 'true';
            const hasCachedBase = ${{ steps.base-coverage.outputs.statements }} > 0;

            const formatDiff = (diff) => {
              const num = parseFloat(diff);
              if (num > 0) return `+${diff}% üìà`;
              if (num < 0) return `${diff}% üìâ`;
              return `${diff}%`;
            };

            const getStatus = () => {
              if (belowMinimum) return '‚ùå **FAILED**: Coverage below 25% minimum threshold';
              if (coverageDecreased) return '‚ùå **FAILED**: Coverage decreased from base branch';
              return '‚úÖ **PASSED**: Coverage maintained or improved';
            };

            const baseNote = hasCachedBase ? '' : '\n\n> ‚ö†Ô∏è No cached coverage for main branch. Comparison will be available after merging.';

            const body = [
              '## üî± Heimdallr Coverage Report',
              '',
              '| Metric | Base (main) | PR | Diff |',
              '|--------|-------------|-----|------|',
              `| Statements | ${baseStmt}% | ${prStmt}% | ${formatDiff(stmtDiff)} |`,
              `| Branches | ${baseBranch}% | ${prBranch}% | ${formatDiff(branchDiff)} |`,
              `| Functions | ${baseFunc}% | ${prFunc}% | ${formatDiff(funcDiff)} |`,
              `| Lines | ${baseLines}% | ${prLines}% | ${formatDiff(linesDiff)} |`,
              '',
              '### Status',
              getStatus() + baseNote,
              '',
              '### Thresholds',
              '- Minimum coverage: **25%**',
              '- Coverage must not decrease from base branch',
              '',
              '---',
              '*üî± Heimdallr watches over your code coverage*',
              '<!-- heimdallr-coverage-report -->'
            ].join('\n');

            // Find existing comment from Heimdallr
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.body && c.body.includes('<!-- heimdallr-coverage-report -->')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Fail if coverage thresholds not met
        run: |
          if [ "${{ steps.diff.outputs.below_minimum }}" = "true" ]; then
            echo "‚ùå Coverage is below 25% minimum threshold"
            exit 1
          fi

          if [ "${{ steps.diff.outputs.coverage_decreased }}" = "true" ]; then
            echo "‚ùå Coverage decreased from base branch"
            exit 1
          fi

          echo "‚úÖ Coverage checks passed"

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build for Cloudflare
        run: npm run build:cloudflare
        env:
          NEXT_PUBLIC_SENTRY_DSN: ${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}

      - name: Upload build artifact
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        uses: actions/upload-artifact@v4
        with:
          name: cloudflare-build
          path: .open-next
          retention-days: 1
          include-hidden-files: true

  deploy:
    name: Deploy to Cloudflare
    runs-on: ubuntu-latest
    needs: [lint, test, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: cloudflare-build
          path: .open-next

      - name: Deploy to Cloudflare Workers
        run: npm run deploy:only
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
